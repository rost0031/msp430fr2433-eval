/*.$file${.::ntag_ao.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: ntag_ao.qm
* File:  ${.::ntag_ao.c}
*
* This code has been generated by QM 5.0.2 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::ntag_ao.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/**
 * @file    main_ao.c
 * @brief   Main QPC Active Object
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Includes ------------------------------------------------------------------*/
#include "qpc.h"
#include "ntag_ao.h"
#include "ntag_cmd_hsm.h"
#include "bsp.h"
#include "signals.h"
#include "ntag.h"
#include "i2c.h"
#include "main_ao.h"

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE

/* Private typedefs ----------------------------------------------------------*/
/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables, objects, and function prototypes -----------------------*/
/*.$declare${AOs::NtagAO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	NTAG "class"
 */
/*.${AOs::NtagAO} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Main timer. */
    QTimeEvt timerMain;

    /** I2C Command HSM pointer */
    QHsm * ntagCmdHsm;

    /** Keep track of errors */
    Error_t status;
} NtagAO;

/* protected: */
static QState NtagAO_initial(NtagAO * const me, QEvt const * const e);

/**
 * @brief    Busy state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState NtagAO_busy(NtagAO * const me, QEvt const * const e);
static QState NtagAO_writePage(NtagAO * const me, QEvt const * const e);
static QState NtagAO_init(NtagAO * const me, QEvt const * const e);
static QState NtagAO_checkEEPROM(NtagAO * const me, QEvt const * const e);

/**
 * @brief    Idle state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState NtagAO_idle(NtagAO * const me, QEvt const * const e);
/*.$enddecl${AOs::NtagAO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static NtagAO l_ntagAO;                        /**< single instance of the AO */

QActive * const AO_Ntag = (QActive *)&l_ntagAO.super; /**< Opaque pointer */

/* Public and Exported functions ---------------------------------------------*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::NtagAO_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     C "constructor" for this "class".
 *
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 *
 * @return None
 */
/*.${AOs::NtagAO_ctor} .....................................................*/
void NtagAO_ctor(void) {
    NtagAO *me = &l_ntagAO;

    QActive_ctor(&me->super, Q_STATE_CAST(&NtagAO_initial));
    me->ntagCmdHsm = NtagCmdHsm_ctor();
    QTimeEvt_ctorX(&me->timerMain, &me->super, TIMER_SIG, 0);
}
/*.$enddef${AOs::NtagAO_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Private functions ---------------------------------------------------------*/
/*.$define${AOs::NtagAO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	NTAG "class"
 */
/*.${AOs::NtagAO} ..........................................................*/
/*.${AOs::NtagAO::SM} ......................................................*/
static QState NtagAO_initial(NtagAO * const me, QEvt const * const e) {
    /*.${AOs::NtagAO::SM::initial} */
    (void)e; /* suppress the compiler warning about unused parameter */

    QHSM_INIT(me->ntagCmdHsm, (QEvt *)0);/*initial tran. for Mine1 */

    QS_OBJ_DICTIONARY(&l_ntagAO);
    QS_FUN_DICTIONARY(&QHsm_top);

    QS_SIG_DICTIONARY(TIMER_SIG, (void *)0);

    QS_SIG_DICTIONARY(NTAG_REG_READ_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_REG_READ_DONE_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_REG_WRITE_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_REG_WRITE_DONE_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_MEM_READ_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_MEM_READ_DONE_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_MEM_WRITE_SIG, (void *)0);
    QS_SIG_DICTIONARY(NTAG_MEM_WRITE_DONE_SIG, (void *)0);

    #if 0
    QActive_subscribe(&me->super, NTAG_REG_READ_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_REG_WRITE_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_MEM_READ_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_MEM_WRITE_DONE_SIG);
    #endif

    QS_FUN_DICTIONARY(&NtagAO_busy);
    QS_FUN_DICTIONARY(&NtagAO_writePage);
    QS_FUN_DICTIONARY(&NtagAO_init);
    QS_FUN_DICTIONARY(&NtagAO_checkEEPROM);
    QS_FUN_DICTIONARY(&NtagAO_idle);

    return Q_TRAN(&NtagAO_init);
}

/**
 * @brief    Busy state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*.${AOs::NtagAO::SM::busy} ................................................*/
static QState NtagAO_busy(NtagAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagAO::SM::busy} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm( &me->timerMain, MSEC_TO_TICKS( 50 ) );

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagAO::SM::busy::NTAG_REG_READ_DONE} */
        case NTAG_REG_READ_DONE_SIG: {
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("Reg Data:");
            QS_U8(1, ((NtagReadRegQEvt_t const *) e)->reg);
            QS_U16(1, ((NtagReadRegQEvt_t const *) e)->value );
            QS_END();

            status_ = Q_TRAN(&NtagAO_idle);
            break;
        }
        /*.${AOs::NtagAO::SM::busy::I2C_TX, I2C_RX} */
        case I2C_TX_SIG: /* intentionally fall through */
        case I2C_RX_SIG: {
            QHSM_DISPATCH(me->ntagCmdHsm, e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagAO::SM::busy::TIMER} */
        case TIMER_SIG: {
            me->status = ERR_HW_TIMEOUT;
            status_ = Q_TRAN(&NtagAO_idle);
            break;
        }
        /*.${AOs::NtagAO::SM::busy::NTAG_MEM_READ_DONE} */
        case NTAG_MEM_READ_DONE_SIG: {
            #if 0
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("MEM addr:");
            QS_U16(1, ((NtagReadMemRespQEvt_t const *) e)->addr );
            QS_STR("bytes:");
            QS_U16(1, ((NtagReadMemRespQEvt_t const *) e)->nBytes );
            QS_STR("data:");
            QS_MEM(((NtagReadMemRespQEvt_t const *) e)->data, ((NtagReadMemRespQEvt_t const *) e)->nBytes);
            QS_END();
            #endif
            QACTIVE_POST(AO_QpcMain, (QEvt *)e, AO_Ntag);
            status_ = Q_TRAN(&NtagAO_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagAO::SM::busy::writePage} .....................................*/
static QState NtagAO_writePage(NtagAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagAO::SM::busy::writePage::NTAG_MEM_WRITE_DONE} */
        case NTAG_MEM_WRITE_DONE_SIG: {
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("MEM Data:");
            QS_U16(1, ((NtagWriteMemRespQEvt_t const *) e)->addr );
            QS_U8(1, ((NtagWriteMemRespQEvt_t const *) e)->nBytes);
            QS_END();


            status_ = Q_TRAN(&NtagAO_checkEEPROM);
            break;
        }
        default: {
            status_ = Q_SUPER(&NtagAO_busy);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagAO::SM::busy::init} ..........................................*/
static QState NtagAO_init(NtagAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagAO::SM::busy::init} */
        case Q_ENTRY_SIG: {
            NtagReadRegQEvt_t *pEvt = Q_NEW(NtagReadRegQEvt_t, NTAG_REG_READ_SIG);
            pEvt->reg = NTAG_MEM_OFFSET_TAG_STATUS_REG;
            pEvt->value = 0xFFFF;
            QHSM_DISPATCH(me->ntagCmdHsm, (QEvt *)pEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagAO::SM::busy::init::NTAG_REG_READ_DONE} */
        case NTAG_REG_READ_DONE_SIG: {
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("Reg Data:");
            QS_U8(1, ((NtagReadRegQEvt_t const *) e)->reg);
            QS_U32_HEX(1, ((NtagReadRegQEvt_t const *) e)->value );
            QS_END();


            /*.${AOs::NtagAO::SM::busy::init::NTAG_REG_READ_DO~::[VCC_OK?]} */
            if (((NtagReadRegQEvt_t const *) e)->value & NTAG_REG_STATUS0_VCC_SUPPLY_OK_MASK) {
                status_ = Q_TRAN(&NtagAO_idle);
            }
            /*.${AOs::NtagAO::SM::busy::init::NTAG_REG_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&NtagAO_init);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&NtagAO_busy);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagAO::SM::busy::checkEEPROM} ...................................*/
static QState NtagAO_checkEEPROM(NtagAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagAO::SM::busy::checkEEPROM} */
        case Q_ENTRY_SIG: {
            NtagReadRegQEvt_t *pEvt = Q_NEW(NtagReadRegQEvt_t, NTAG_REG_READ_SIG);
            pEvt->reg = NTAG_MEM_OFFSET_TAG_STATUS_REG;
            pEvt->value = 0xFFFF;
            QHSM_DISPATCH(me->ntagCmdHsm, (QEvt *)pEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagAO::SM::busy::checkEEPROM::NTAG_REG_READ_DONE} */
        case NTAG_REG_READ_DONE_SIG: {
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("Reg Data1:");
            QS_U8(1, ((NtagReadRegQEvt_t const *) e)->reg);
            QS_U32_HEX(1, ((NtagReadRegQEvt_t const *) e)->value );
            QS_END();


            /*.${AOs::NtagAO::SM::busy::checkEEPROM::NTAG_REG_READ_DO~::[WriteBusy?]} */
            if (((NtagReadRegQEvt_t const *) e)->value & NTAG_REG_STATUS0_PT_EEPROM_WRITE_BUSY_MASK) {
                status_ = Q_TRAN(&NtagAO_checkEEPROM);
            }
            /*.${AOs::NtagAO::SM::busy::checkEEPROM::NTAG_REG_READ_DO~::[else]} */
            else {
                NtagWriteMemRespQEvt_t* pEvt = Q_NEW(NtagWriteMemRespQEvt_t, NTAG_MEM_WRITE_DONE_SIG);
                pEvt->addr = 0;
                pEvt->nBytes = 4;
                QACTIVE_POST(AO_QpcMain, (QEvt *)pEvt, AO_Ntag);
                status_ = Q_TRAN(&NtagAO_idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&NtagAO_busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Idle state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*.${AOs::NtagAO::SM::idle} ................................................*/
static QState NtagAO_idle(NtagAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagAO::SM::idle} */
        case Q_ENTRY_SIG: {
            /* Handle error if one occurred. */

            // TODO: do we want to post an event in case of error? - HR
            if (ERR_NONE != me->status) {
                QS_BEGIN(ERR, 0);       /* application-specific record begin */
                QS_STR("NTAG error:");
                QS_U32_HEX(2, me->status);
                QS_END();

                me->status = ERR_NONE;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagAO::SM::idle::NTAG_REG_READ} */
        case NTAG_REG_READ_SIG: {
            //NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);
            QHSM_DISPATCH(me->ntagCmdHsm, e);
            status_ = Q_TRAN(&NtagAO_busy);
            break;
        }
        /*.${AOs::NtagAO::SM::idle::NTAG_MEM_READ} */
        case NTAG_MEM_READ_SIG: {
            //NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);
            QHSM_DISPATCH(me->ntagCmdHsm, e);
            status_ = Q_TRAN(&NtagAO_busy);
            break;
        }
        /*.${AOs::NtagAO::SM::idle::NTAG_MEM_WRITE} */
        case NTAG_MEM_WRITE_SIG: {
            QHSM_DISPATCH(me->ntagCmdHsm, e);
            status_ = Q_TRAN(&NtagAO_writePage);
            break;
        }
        /*.${AOs::NtagAO::SM::idle::NTAG_MEM_WRITE_DONE} */
        case NTAG_MEM_WRITE_DONE_SIG: {
            QS_BEGIN(LOG, 0);       /* application-specific record begin */
            QS_STR("MEM Data:");
            QS_U16(1, ((NtagWriteMemRespQEvt_t const *) e)->addr );
            QS_U8(1, ((NtagWriteMemRespQEvt_t const *) e)->nBytes);
            QS_END();
            QACTIVE_POST(AO_QpcMain, (QEvt *)e, AO_Ntag);
            status_ = Q_TRAN(&NtagAO_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::NtagAO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
