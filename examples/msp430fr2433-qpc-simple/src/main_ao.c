/*.$file${.::main_ao.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: main_ao.qm
* File:  ${.::main_ao.c}
*
* This code has been generated by QM 5.0.2 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::main_ao.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/**
 * @file    main_ao.c
 * @brief   Main QPC Active Object
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Includes ------------------------------------------------------------------*/
#include "qpc.h"
#include "main_ao.h"
#include "bsp.h"
#include "signals.h"
#include "ntag.h"
#include "i2c.h"
#include "ntag_ao.h"

/* Compile-time called macros ------------------------------------------------*/
//Q_DEFINE_THIS_FILE

/* Private typedefs ----------------------------------------------------------*/
/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables, objects, and function prototypes -----------------------*/
/*.$declare${AOs::QpcMain} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	Main "class"
 */
/*.${AOs::QpcMain} .........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Main timer. */
    QTimeEvt timerMain;
    uint16_t addr;
    uint8_t byte;
} QpcMain;

/* protected: */
static QState QpcMain_initial(QpcMain * const me, QEvt const * const e);

/**
 * @brief    Top-level state where everything happens
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState QpcMain_active(QpcMain * const me, QEvt const * const e);

/**
 * @brief    First substate for demo purpose
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState QpcMain_FirstSubState(QpcMain * const me, QEvt const * const e);
static QState QpcMain_state1(QpcMain * const me, QEvt const * const e);
static QState QpcMain_state2(QpcMain * const me, QEvt const * const e);
/*.$enddecl${AOs::QpcMain} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static QpcMain l_qpcMain;                      /**< single instance of the AO */

QActive * const AO_QpcMain = (QActive *)&l_qpcMain.super; /**< Opaque pointer */

/* Public and Exported functions ---------------------------------------------*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::QpcMain_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     C "constructor" for this "class".
 *
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 *
 * @return None
 */
/*.${AOs::QpcMain_ctor} ....................................................*/
void QpcMain_ctor(void) {
    QpcMain *me = &l_qpcMain;

    QActive_ctor(&me->super, Q_STATE_CAST(&QpcMain_initial));

    QTimeEvt_ctorX(&me->timerMain, &me->super, TIMER_SIG, 0);
}
/*.$enddef${AOs::QpcMain_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Private functions ---------------------------------------------------------*/
/*.$define${AOs::QpcMain} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	Main "class"
 */
/*.${AOs::QpcMain} .........................................................*/
/*.${AOs::QpcMain::SM} .....................................................*/
static QState QpcMain_initial(QpcMain * const me, QEvt const * const e) {
    /*.${AOs::QpcMain::SM::initial} */
    (void)e; /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_qpcMain);
    QS_FUN_DICTIONARY(&QHsm_top);

    QS_SIG_DICTIONARY(TERMINATE_SIG, (void *)0);
    QS_SIG_DICTIONARY(TIMER_SIG, (void *)0);

    QActive_subscribe(&me->super, NTAG_REG_READ_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_REG_WRITE_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_MEM_READ_DONE_SIG);
    QActive_subscribe(&me->super, NTAG_MEM_WRITE_DONE_SIG);
    return Q_TRAN(&QpcMain_FirstSubState);
}

/**
 * @brief    Top-level state where everything happens
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*.${AOs::QpcMain::SM::active} .............................................*/
static QState QpcMain_active(QpcMain * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::QpcMain::SM::active::TERMINATE} */
        case TERMINATE_SIG: {
            BSP_terminate(0);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief    First substate for demo purpose
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*.${AOs::QpcMain::SM::active::FirstSubState} ..............................*/
static QState QpcMain_FirstSubState(QpcMain * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::QpcMain::SM::active::FirstSubState} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm( &me->timerMain, MSEC_TO_TICKS( 1000 ) );

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::QpcMain::SM::active::FirstSubState::TIMER} */
        case TIMER_SIG: {
            QTimeEvt_rearm( &me->timerMain, MSEC_TO_TICKS( 1000 ) );
            me->addr = 6;
            //P1OUT ^=  LED1;  /* toggle LED1 */
            status_ = Q_TRAN(&QpcMain_state1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QpcMain_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::QpcMain::SM::active::state1} .....................................*/
static QState QpcMain_state1(QpcMain * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::QpcMain::SM::active::state1} */
        case Q_ENTRY_SIG: {
            NtagReadMemReqQEvt_t *pEvt = Q_NEW(NtagReadMemReqQEvt_t, NTAG_MEM_READ_SIG);
            pEvt->nBytes = 4;
            pEvt->addr = me->addr;
            QACTIVE_POST(AO_Ntag, (QEvt *)pEvt, me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::QpcMain::SM::active::state1::NTAG_MEM_READ_DONE} */
        case NTAG_MEM_READ_DONE_SIG: {
            me->addr++;
            /*.${AOs::QpcMain::SM::active::state1::NTAG_MEM_READ_DO~::[me->addr<12]} */
            if (me->addr < 12) {
                status_ = Q_TRAN(&QpcMain_state1);
            }
            /*.${AOs::QpcMain::SM::active::state1::NTAG_MEM_READ_DO~::[else]} */
            else {
                me->byte = 0;
                me->addr = 6;
                status_ = Q_TRAN(&QpcMain_state2);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QpcMain_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::QpcMain::SM::active::state2} .....................................*/
static QState QpcMain_state2(QpcMain * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::QpcMain::SM::active::state2} */
        case Q_ENTRY_SIG: {
            NtagWriteMemReqQEvt_t *pEvt = Q_NEW(NtagWriteMemReqQEvt_t, NTAG_MEM_WRITE_SIG);
            pEvt->nBytes = 4;
            pEvt->addr = me->addr;
            pEvt->data[0] = me->byte++;
            pEvt->data[1] = me->byte++;
            pEvt->data[2] = me->byte++;
            pEvt->data[3] = me->byte++;
            QACTIVE_POST(AO_Ntag, (QEvt *)pEvt, me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::QpcMain::SM::active::state2::NTAG_MEM_WRITE_DONE} */
        case NTAG_MEM_WRITE_DONE_SIG: {
            me->addr++;
            /*.${AOs::QpcMain::SM::active::state2::NTAG_MEM_WRITE_D~::[me->addr<12]} */
            if (me->addr < 12) {
                status_ = Q_TRAN(&QpcMain_state2);
            }
            /*.${AOs::QpcMain::SM::active::state2::NTAG_MEM_WRITE_D~::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QpcMain_active);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::QpcMain} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
