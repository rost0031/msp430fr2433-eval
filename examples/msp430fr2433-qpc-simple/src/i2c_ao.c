/*.$file${.::i2c_ao.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: i2c_ao.qm
* File:  ${.::i2c_ao.c}
*
* This code has been generated by QM 5.0.2 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::i2c_ao.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/**
 * @file    i2c_ao.c
 * @brief   I2C QPC Active Object
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Includes ------------------------------------------------------------------*/

#include "i2c_ao.h"
#include "bsp.h"
#include "signals.h"
#include "i2c.h"

/* Compile-time called macros ------------------------------------------------*/
//Q_DEFINE_THIS_FILE

/* Private typedefs ----------------------------------------------------------*/
/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables, objects, and function prototypes -----------------------*/
/*.$declare${AOs::I2CAO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	I2C "class"
 */
/*.${AOs::I2CAO} ...........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Main timer. */
    QTimeEvt timerMain;

    /** Reference to an event currently being handled. This is necessary so
     * we can avoid copying data to local storage from an event and instead
     * hold on to that event via this reference and manually garbage collect
     * it after we are finished. */
    QpcI2CEvt_t const* pActiveRequest;

    /** Keep track of errors that might happen */
    Error_t status;

/* private: */
    QEQueue requestQueue;

    /** Storage for deferred events */
    QEvt const * requestQSto[3];
} I2CAO;

/* protected: */
static QState I2CAO_initial(I2CAO * const me, QEvt const * const e);
static QState I2CAO_idle(I2CAO * const me, QEvt const * const e);
static QState I2CAO_busy(I2CAO * const me, QEvt const * const e);
static QState I2CAO_tx(I2CAO * const me, QEvt const * const e);
static QState I2CAO_rx(I2CAO * const me, QEvt const * const e);
/*.$enddecl${AOs::I2CAO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static I2CAO l_I2C;                            /**< single instance of the AO */

QActive * const AO_I2C = (QActive *)&l_I2C.super;   /**< Opaque pointer */

/*.$declare${AOs::I2CAO_txDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2CAO_txDoneCallback} ............................................*/
static void I2CAO_txDoneCallback(const I2CData_t* const pI2CData);
/*.$enddecl${AOs::I2CAO_txDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Public and Exported functions ---------------------------------------------*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::I2CAO_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     C "constructor" for this "class".
 *
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 *
 * @return None
 */
/*.${AOs::I2CAO_ctor} ......................................................*/
void I2CAO_ctor(void) {
    I2CAO *me = &l_I2C;

    QActive_ctor(&me->super, Q_STATE_CAST(&I2CAO_initial));
    QEQueue_init(&me->requestQueue,
                  me->requestQSto, Q_DIM(me->requestQSto));
    QTimeEvt_ctorX(&me->timerMain, &me->super, TIMER_SIG, 0);
}
/*.$enddef${AOs::I2CAO_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Private functions ---------------------------------------------------------*/
/*.$define${AOs::I2CAO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief	I2C "class"
 */
/*.${AOs::I2CAO} ...........................................................*/
/*.${AOs::I2CAO::SM} .......................................................*/
static QState I2CAO_initial(I2CAO * const me, QEvt const * const e) {
    /*.${AOs::I2CAO::SM::initial} */
    (void)e; /* suppress the compiler warning about unused parameter */


    QS_OBJ_DICTIONARY(&l_I2C);
    QS_FUN_DICTIONARY(&QHsm_top);

    QS_SIG_DICTIONARY(TIMER_SIG, (void *)0);
    QS_SIG_DICTIONARY(I2C_RX_SIG, (void *)0);
    QS_SIG_DICTIONARY(I2C_TX_SIG, (void *)0);
    QS_SIG_DICTIONARY(I2C_RX_DONE_SIG, (void *)0);
    QS_SIG_DICTIONARY(I2C_TX_DONE_SIG, (void *)0);

    me->status = ERR_NONE;

    QS_FUN_DICTIONARY(&I2CAO_idle);
    QS_FUN_DICTIONARY(&I2CAO_busy);
    QS_FUN_DICTIONARY(&I2CAO_tx);
    QS_FUN_DICTIONARY(&I2CAO_rx);

    return Q_TRAN(&I2CAO_idle);
}
/*.${AOs::I2CAO::SM::idle} .................................................*/
static QState I2CAO_idle(I2CAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::I2CAO::SM::idle} */
        case Q_ENTRY_SIG: {
            /* Always NULL out the current request upon entry */
            me->pActiveRequest = (QpcI2CEvt_t const *)0;

            /* Handle error if one occurred. */

            // TODO: do we want to post an event in case of error? - HR
            if (ERR_NONE != me->status) {
                QS_BEGIN(ERR, 0);       /* application-specific record begin */
                QS_STR("I2C error:");
                QS_U32_HEX(1, me->status);
                QS_END();

                me->status = ERR_NONE;
            }

            /* Attempt to recall oldest deferred event. If one exists, this will
             * also automatically post it to this AO */
            QActive_recall(&me->super, &me->requestQueue);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::idle::I2C_RX} */
        case I2C_RX_SIG: {
            /* Save the current event reference so the event doesn't go away */
            Q_NEW_REF(me->pActiveRequest, QpcI2CEvt_t);
            status_ = Q_TRAN(&I2CAO_rx);
            break;
        }
        /*.${AOs::I2CAO::SM::idle::I2C_TX} */
        case I2C_TX_SIG: {
            /* Save the current event reference so the event doesn't go away */
            Q_NEW_REF(me->pActiveRequest, QpcI2CEvt_t);
            status_ = Q_TRAN(&I2CAO_tx);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::I2CAO::SM::busy} .................................................*/
static QState I2CAO_busy(I2CAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::I2CAO::SM::busy} */
        case Q_ENTRY_SIG: {
            /* Arm timer upon entry to busy state to prevent being stuck here */
            QTimeEvt_rearm(&me->timerMain, MSEC_TO_TICKS(10));
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::busy} */
        case Q_EXIT_SIG: {
            /* Upon exit, ALWAYS delete the active event reference */
            Q_DELETE_REF(me->pActiveRequest);

            /* If the timer doesn't fire, kill it upon exit */
            QTimeEvt_disarm(&me->timerMain);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::busy::I2C_TX, I2C_RX} */
        case I2C_TX_SIG: /* intentionally fall through */
        case I2C_RX_SIG: {
            /* attempt to defer the new request event */
            if (!QActive_defer(&me->super, &me->requestQueue, e)) {
                me->status = ERR_MEM_OUT;
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::busy::TIMER} */
        case TIMER_SIG: {
            status_ = Q_TRAN(&I2CAO_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::I2CAO::SM::busy::tx} .............................................*/
static QState I2CAO_tx(I2CAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::I2CAO::SM::busy::tx} */
        case Q_ENTRY_SIG: {
            I2C_exchangeNonBlocking(
                me->pActiveRequest->deviceAddress,
                I2CCmdTx,
                me->pActiveRequest->size,
                me->pActiveRequest->data
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::busy::tx::I2C_TX_DONE} */
        case I2C_TX_DONE_SIG: {
            status_ = Q_TRAN(&I2CAO_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2CAO_busy);
            break;
        }
    }
    return status_;
}
/*.${AOs::I2CAO::SM::busy::rx} .............................................*/
static QState I2CAO_rx(I2CAO * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::I2CAO::SM::busy::rx} */
        case Q_ENTRY_SIG: {
            I2C_exchangeNonBlocking(
                me->pActiveRequest->deviceAddress,
                I2CCmdRx,
                me->pActiveRequest->size,
                me->pActiveRequest->data
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::I2CAO::SM::busy::rx::I2C_RX_DONE} */
        case I2C_RX_DONE_SIG: {
            status_ = Q_TRAN(&I2CAO_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2CAO_busy);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::I2CAO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::I2CAO_txDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2CAO_txDoneCallback} ............................................*/
static void I2CAO_txDoneCallback(const I2CData_t* const pI2CData) {
    static const QEvt evt = {I2C_TX_DONE_SIG, 0, 0};
    QACTIVE_POST(AO_I2C, &evt, AO_I2C);
}
/*.$enddef${AOs::I2CAO_txDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
