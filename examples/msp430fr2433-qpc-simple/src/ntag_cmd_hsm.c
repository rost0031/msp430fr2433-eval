/*.$file${.::ntag_cmd_hsm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: ntag_ao.qm
* File:  ${.::ntag_cmd_hsm.c}
*
* This code has been generated by QM 5.0.2 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::ntag_cmd_hsm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/**
 * @file    ntag_cmd_ao.c
 * @brief   NTAG CMD QPC HSM
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Includes ------------------------------------------------------------------*/
#include "qpc.h"
#include "ntag_ao.h"
#include "ntag_cmd_hsm.h"
#include "bsp.h"
#include "signals.h"
#include "ntag.h"

/* Compile-time called macros ------------------------------------------------*/
//Q_DEFINE_THIS_FILE

/* Private typedefs ----------------------------------------------------------*/
/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables, objects, and function prototypes -----------------------*/
/*.$declare${AOs::NtagCmdHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::NtagCmdHsm} ......................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* private: */

    /** Offset within the register. This is necessary for registers that
     * are bigger than a single byte */
    uint8_t regOffset;

    /** Size of a register */
    uint8_t regSize;

/* protected: */

    /** Reference to an event currently being handled. This is necessary so
     * we can avoid copying data to local storage from an event and instead
     * hold on to that event via this reference and manually garbage collect
     * it after we are finished. */
    NtagReadRegEvt_t * pActiveRequest;

    /** Internal data storage to use with I2C driver */
    uint8_t dataBufTx[6];

    /** Number of bytes in dataBufTx */
    uint8_t dataLenTx;

    /** Internal data storage to use with I2C driver */
    uint8_t dataBufRx[6];

    /** Number of bytes in dataBufRx */
    uint8_t dataLenRx;

    /** Keep track of status and/or errors that can occur */
    Error_t status;
} NtagCmdHsm;

/* protected: */
static QState NtagCmdHsm_initial(NtagCmdHsm * const me, QEvt const * const e);
static QState NtagCmdHsm_idle(NtagCmdHsm * const me, QEvt const * const e);
static QState NtagCmdHsm_busy(NtagCmdHsm * const me, QEvt const * const e);
static QState NtagCmdHsm_writeAddress(NtagCmdHsm * const me, QEvt const * const e);
static QState NtagCmdHsm_readByte(NtagCmdHsm * const me, QEvt const * const e);
/*.$enddecl${AOs::NtagCmdHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static NtagCmdHsm l_ntagCmdHsm;               /**< single instance of the HSM */

QHsm* const HSM_NtagCmd = (QHsm *)&l_ntagCmdHsm.super;     /**< Opaque pointer */

/*.$declare${AOs::I2C_txDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2C_txDoneCallback} ..............................................*/
static void I2C_txDoneCallback(const I2CData_t* const pI2CData);
/*.$enddecl${AOs::I2C_txDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${AOs::I2C_rxDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2C_rxDoneCallback} ..............................................*/
static void I2C_rxDoneCallback(const I2CData_t* const pI2CData);
/*.$enddecl${AOs::I2C_rxDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Public and Exported functions ---------------------------------------------*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::NtagCmdHsm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief C "constructor" for this HSM "class" that handles NTAG commands
 *
 * @return None
 */
/*.${AOs::NtagCmdHsm_ctor} .................................................*/
QHsm * NtagCmdHsm_ctor(void) {
    NtagCmdHsm *me;
    me = &l_ntagCmdHsm;
    /* superclass' ctor */
    QHsm_ctor(&me->super, Q_STATE_CAST(&NtagCmdHsm_initial));
    return (QHsm *)me;
}
/*.$enddef${AOs::NtagCmdHsm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::I2C_txDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2C_txDoneCallback} ..............................................*/
static void I2C_txDoneCallback(const I2CData_t* const pI2CData) {
    /* Get access to internal memory of the HSM structure */
    NtagCmdHsm *me;
    me = &l_ntagCmdHsm;

    me->dataLenTx += pI2CData->buffer.len;
    me->status = pI2CData->status;

    static const QEvt evt = {I2C_TX_SIG, 0, 0};
    QACTIVE_POST(AO_Ntag, &evt, AO_Ntag);
}
/*.$enddef${AOs::I2C_txDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::I2C_rxDoneCallback} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * @brief     Callback for I2C TX being done
 * @return None
 */
/*.${AOs::I2C_rxDoneCallback} ..............................................*/
static void I2C_rxDoneCallback(const I2CData_t* const pI2CData) {
    /* Get access to internal memory of the HSM structure */
    NtagCmdHsm *me;
    me = &l_ntagCmdHsm;

    me->dataLenRx += pI2CData->buffer.len;
    me->status = pI2CData->status;

    static const QEvt evt = {I2C_RX_SIG, 0, 0};
    QACTIVE_POST(AO_Ntag, &evt, AO_Ntag);
}
/*.$enddef${AOs::I2C_rxDoneCallback} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Private functions ---------------------------------------------------------*/
/*.$define${AOs::NtagCmdHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::NtagCmdHsm} ......................................................*/
/*.${AOs::NtagCmdHsm::SM} ..................................................*/
static QState NtagCmdHsm_initial(NtagCmdHsm * const me, QEvt const * const e) {
    /*.${AOs::NtagCmdHsm::SM::initial} */
    (void)e; /* avoid the "unreferenced parameter" warning */

    QS_OBJ_DICTIONARY(&l_ntagCmdHsm);

    QS_FUN_DICTIONARY(&NtagCmdHsm_idle);
    QS_FUN_DICTIONARY(&NtagCmdHsm_busy);
    QS_FUN_DICTIONARY(&NtagCmdHsm_writeAddress);
    QS_FUN_DICTIONARY(&NtagCmdHsm_readByte);

    return Q_TRAN(&NtagCmdHsm_idle);
}
/*.${AOs::NtagCmdHsm::SM::idle} ............................................*/
static QState NtagCmdHsm_idle(NtagCmdHsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagCmdHsm::SM::idle} */
        case Q_ENTRY_SIG: {
            /* Always clear out register data upon entry */
            me->regSize   = 0;
            me->regOffset = 0;

            me->dataLenTx = 0;
            me->dataLenRx = 0;

            /* Always NULL out the current request upon entry */
            me->pActiveRequest = (NtagReadRegEvt_t *)0;

            /* Handle error if one occurred. */

            // TODO: do we want to post an event in case of error? - HR
            if (ERR_NONE != me->status) {
                QS_BEGIN(ERR, 0);       /* application-specific record begin */
                QS_STR("I2C error:");
                QS_U32_HEX(1, me->status);
                QS_END();

                me->status = ERR_NONE;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagCmdHsm::SM::idle::NTAG_REG_READ} */
        case NTAG_REG_READ_SIG: {
            /* Save the current event reference so the event doesn't go away */
            Q_NEW_REF(me->pActiveRequest, NtagReadRegEvt_t);

            /* Get register size and clear offset */
            me->regSize = NTAG_getRegSize(me->pActiveRequest->reg);
            me->regOffset = 0;
            status_ = Q_TRAN(&NtagCmdHsm_writeAddress);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagCmdHsm::SM::busy} ............................................*/
static QState NtagCmdHsm_busy(NtagCmdHsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagCmdHsm::SM::busy} */
        case Q_EXIT_SIG: {
            /* Upon exit, ALWAYS delete the active event reference */
            Q_DELETE_REF(me->pActiveRequest);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagCmdHsm::SM::busy::writeAddress} ..............................*/
static QState NtagCmdHsm_writeAddress(NtagCmdHsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagCmdHsm::SM::busy::writeAddress} */
        case Q_ENTRY_SIG: {
            #if 0
            QpcI2CEvt_t* pEvt = Q_NEW(QpcI2CEvt_t, I2C_TX_SIG);
            pEvt->reg = me->pActiveRequest->reg;
            NTAG_getRegReadHdr(pEvt->reg, me->offset, sizeof(pEvt->data),
                &(pEvt->size), pEvt->data);
            QACTIVE_POST(AO_I2C, (QEvt *)pEvt, AO_Ntag);
            #endif

            /* Fill out me->dataBuf and me->dataLen with data needed to write
             * address of the register to tag */
            NTAG_getRegReadHdr(
                me->pActiveRequest->reg,
                me->regOffset,
                sizeof(me->dataBufTx),
                &(me->dataLenTx),
                me->dataBufTx
            );

            /* Register callback to call when the I2C TX completes */
            I2C_regCallback(I2C_txDoneCallback);

            /* Initiate a non-blocking I2C TX command */
            I2C_exchangeNonBlocking(
                NTAG_I2C_ADDRESS,
                I2CCmdTx,
                me->dataLenTx,
                me->dataBufTx
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagCmdHsm::SM::busy::writeAddress::I2C_TX} */
        case I2C_TX_SIG: {
            status_ = Q_TRAN(&NtagCmdHsm_readByte);
            break;
        }
        default: {
            status_ = Q_SUPER(&NtagCmdHsm_busy);
            break;
        }
    }
    return status_;
}
/*.${AOs::NtagCmdHsm::SM::busy::readByte} ..................................*/
static QState NtagCmdHsm_readByte(NtagCmdHsm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::NtagCmdHsm::SM::busy::readByte} */
        case Q_ENTRY_SIG: {

            /* Register callback to call when the I2C RX completes */
            I2C_regCallback(I2C_rxDoneCallback);

            /* Initiate a non-blocking I2C RX command */
            I2C_exchangeNonBlocking(
                NTAG_I2C_ADDRESS,
                I2CCmdRx,
                1,
                &me->dataBufRx[0 + me->regOffset]
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::NtagCmdHsm::SM::busy::readByte::I2C_RX} */
        case I2C_RX_SIG: {
            me->regOffset++;
            /*.${AOs::NtagCmdHsm::SM::busy::readByte::I2C_RX::[More?]} */
            if (me->regOffset < me->regSize) {
                status_ = Q_TRAN(&NtagCmdHsm_writeAddress);
            }
            /*.${AOs::NtagCmdHsm::SM::busy::readByte::I2C_RX::[else]} */
            else {
                /* Use the current active request event to send back data */
                me->pActiveRequest->value = (uint16_t)me->dataBufRx[0];
                if (me->regSize == 2) {
                    me->pActiveRequest->value |= (uint16_t)(me->dataBufRx[1] << 8);
                }
                QACTIVE_POST(AO_Ntag, (QEvt *)(me->pActiveRequest), AO_Ntag);
                status_ = Q_TRAN(&NtagCmdHsm_idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&NtagCmdHsm_busy);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::NtagCmdHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
