<?xml version="1.0" encoding="UTF-8"?>
<model version="5.0.2" links="1">
 <documentation>Dining Philosopher Problem example

NOTE: Requries QP5.</documentation>
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${Events}-->
 <package name="Events" stereotype="0x01">
  <!--${Events::NtagReadRegEvt}-->
  <class name="NtagReadRegEvt" superclass="qpc::QEvt">
   <documentation>/** @brief NTAG event */</documentation>
   <!--${Events::NtagReadRegEvt::reg}-->
   <attribute name="reg" type="NTAGRegNumber_t" visibility="0x01" properties="0x00">
    <documentation>/** Which register to read */</documentation>
   </attribute>
   <!--${Events::NtagReadRegEvt::value}-->
   <attribute name="value" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/** Value of the register (if used for a response) */</documentation>
   </attribute>
  </class>
 </package>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::QpcNtag}-->
  <class name="QpcNtag" superclass="qpc::QActive">
   <documentation>/**
 * @brief	NTAG &quot;class&quot;
 */</documentation>
   <!--${AOs::QpcNtag::timerMain}-->
   <attribute name="timerMain" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Main timer. */</documentation>
   </attribute>
   <!--${AOs::QpcNtag::SM}-->
   <statechart properties="0x03">
    <!--${AOs::QpcNtag::SM::initial}-->
    <initial target="../1/1">
     <action>(void)e; /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_qpcNtag);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;QpcNtag_initial);
QS_FUN_DICTIONARY(&amp;QpcNtag_active);
QS_FUN_DICTIONARY(&amp;QpcNtag_idle);
QS_FUN_DICTIONARY(&amp;QpcNtag_busy);
QS_FUN_DICTIONARY(&amp;QpcNtag_init);

QS_SIG_DICTIONARY(TIMER_SIG, (void *)0);

QS_SIG_DICTIONARY(NTAG_REG_READ_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_REG_READ_DONE_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_REG_WRITE_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_REG_WRITE_DONE_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_MEM_READ_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_MEM_READ_DONE_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_MEM_WRITE_SIG, (void *)0);
QS_SIG_DICTIONARY(NTAG_MEM_WRITE_DONE_SIG, (void *)0);</action>
     <initial_glyph conn="3,3,5,0,7,7">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::QpcNtag::SM::active}-->
    <state name="active">
     <documentation>/**
 * @brief    Top-level state where everything happens
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <!--${AOs::QpcNtag::SM::active::busy}-->
     <state name="busy">
      <documentation>/**
 * @brief    Busy state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>//QTimeEvt_rearm( &amp;me-&gt;timerMain, MSEC_TO_TICKS( 1000 ) );
//NTAG_init();</entry>
      <!--${AOs::QpcNtag::SM::active::busy::TIMER}-->
      <tran trig="TIMER">
       <action>QTimeEvt_rearm( &amp;me-&gt;timerMain, MSEC_TO_TICKS( 1000 ) );
</action>
       <tran_glyph conn="43,76,3,-1,34">
        <action box="0,-2,7,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::QpcNtag::SM::active::busy::init}-->
      <state name="init">
       <entry>//QTimeEvt_rearm( &amp;me-&gt;timerMain, MSEC_TO_TICKS( 100 ) );
//NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);
NTAG_init();</entry>
       <!--${AOs::QpcNtag::SM::active::busy::init::NTAG_REG_READ_DONE}-->
       <tran trig="NTAG_REG_READ_DONE" target="../../2">
        <tran_glyph conn="52,27,2,0,3">
         <action box="0,-2,24,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="47,16,23,11">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <!--${AOs::QpcNtag::SM::active::busy::state1}-->
      <state name="state1">
       <entry>//QTimeEvt_rearm( &amp;me-&gt;timerMain, MSEC_TO_TICKS( 100 ) );
//NTAG_init();
//NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);
NTAG_readRegWithCallback(NTAG_MEM_OFFSET_TAG_STATUS_REG, NtagEvtDone, QpcNtag_regReadDoneCallback);</entry>
       <!--${AOs::QpcNtag::SM::active::busy::state1::NTAG_REG_READ_DONE}-->
       <tran trig="NTAG_REG_READ_DONE">
        <action>QS_BEGIN(LOG, 0);       /* application-specific record begin */
QS_STR(&quot;Reg Data:&quot;);
QS_U8(1, ((NtagReadRegEvt const *) e)-&gt;reg);
QS_U16(1, ((NtagReadRegEvt const *) e)-&gt;value );
QS_END();

</action>
        <!--${AOs::QpcNtag::SM::active::busy::state1::NTAG_REG_READ_DO~::[Valid?]}-->
        <choice>
         <guard brief="Valid?">((NtagReadRegEvt const *) e)-&gt;value != 0xFFFF</guard>
         <!--${AOs::QpcNtag::SM::active::busy::state1::NTAG_REG_READ_DO~::[Valid?]::[VCC_OK?]}-->
         <choice target="../../../../3">
          <guard brief="VCC_OK?">((NtagReadRegEvt const *) e)-&gt;value &amp; NTAG_REG_STATUS0_VCC_SUPPLY_OK_MASK</guard>
          <choice_glyph conn="51,48,4,0,6">
           <action box="-8,1,10,2"/>
          </choice_glyph>
         </choice>
         <!--${AOs::QpcNtag::SM::active::busy::state1::NTAG_REG_READ_DO~::[Valid?]::[else]}-->
         <choice target="../../..">
          <guard>else</guard>
          <choice_glyph conn="51,48,5,1,21,-15,-2">
           <action box="3,-2,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="51,43,4,-1,5">
          <action box="-6,1,7,2"/>
         </choice_glyph>
        </choice>
        <!--${AOs::QpcNtag::SM::active::busy::state1::NTAG_REG_READ_DO~::[else]}-->
        <choice target="../..">
         <guard>else</guard>
         <choice_glyph conn="51,43,5,1,21,-10,-2">
          <action box="7,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="51,36,2,-1,7">
         <action box="0,1,21,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="48,30,22,6">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <!--${AOs::QpcNtag::SM::active::busy::state2}-->
      <state name="state2">
       <entry>NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);</entry>
       <state_glyph node="48,54,22,6">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="43,10,51,69">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <!--${AOs::QpcNtag::SM::active::idle}-->
     <state name="idle">
      <documentation>/**
 * @brief    Idle state
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>QTimeEvt_rearm( &amp;me-&gt;timerMain, MSEC_TO_TICKS( 100 ) );
</entry>
      <!--${AOs::QpcNtag::SM::active::idle::NTAG_REG_READ}-->
      <tran trig="NTAG_REG_READ">
       <action>NTAG_readReg(NTAG_MEM_OFFSET_TAG_STATUS_REG);
</action>
       <tran_glyph conn="6,38,3,-1,28">
        <action box="0,-2,16,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::QpcNtag::SM::active::idle::TIMER}-->
      <tran trig="TIMER" target="../../0/2">
       <tran_glyph conn="6,20,3,3,40,13,2">
        <action box="0,-2,7,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,10,25,43">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="2,5,119,79"/>
    </state>
    <state_diagram size="133,104"/>
   </statechart>
  </class>
  <!--${AOs::AO_QpcNtag}-->
  <attribute name="AO_QpcNtag" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/** &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <!--${AOs::QpcNtag_ctor}-->
  <operation name="QpcNtag_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief     C &quot;constructor&quot; for this &quot;class&quot;.
 *
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 *
 * @return None
 */</documentation>
   <code>QpcNtag *me = &amp;l_qpcNtag;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;QpcNtag_initial));

QTimeEvt_ctorX(&amp;me-&gt;timerMain, &amp;me-&gt;super, TIMER_SIG, 0);</code>
  </operation>
  <!--${AOs::QpcNtag_regReadDoneCallback}-->
  <operation name="QpcNtag_regReadDoneCallback" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief     Callback that the NTAG driver will call when finished
 *
 * @return None
 */</documentation>
   <!--${AOs::QpcNtag_regReadD~::pNtagData}-->
   <parameter name="pNtagData" type="const NtagData_t* const"/>
   <code>NtagReadRegEvt* pEvt = Q_NEW(NtagReadRegEvt, NTAG_REG_READ_DONE_SIG);
pEvt-&gt;reg = pNtagData-&gt;currRegNumber;
pEvt-&gt;value = ((uint16_t)(pNtagData-&gt;bufferRx.pData[1] &lt;&lt; 8) |
               (uint16_t)(pNtagData-&gt;bufferRx.pData[0]));
QACTIVE_POST(AO_QpcNtag, (QEvt *)pEvt, AO_QpcNtag);

#if 0
QS_BEGIN(LOG, 0);       /* application-specific record begin */
QS_STR(&quot;Reg Data:&quot;);
for (uint8_t i = 0; i &lt; pNtagData-&gt;bufferRx.len; i++) {
    QS_U8(1, pNtagData-&gt;bufferRx.pData[i]);
}
QS_END();
#endif</code>
  </operation>
 </package>
 <!--${.}-->
 <directory name=".">
  <!--${.::ntag_ao.h}-->
  <file name="ntag_ao.h">
   <text>/**
 * @file    ntag_ao.h
 * @brief   NTAG5 QPC Active Object
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __NTAG_AO_H
#define __NTAG_AO_H

/* Includes ------------------------------------------------------------------*/
#include &quot;ntag.h&quot;
/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/

$declare(Events::NtagReadRegEvt)

/* Exported constants --------------------------------------------------------*/
$declare(AOs::AO_QpcNtag)

/* Exported functions --------------------------------------------------------*/
$declare(AOs::QpcNtag_ctor)


#endif                                                         /* __MAIN_AO_H */
</text>
  </file>
  <!--${.::ntag_ao.c}-->
  <file name="ntag_ao.c">
   <text>/**
 * @file    main_ao.c
 * @brief   Main QPC Active Object
 *
 * Copyright 2020, Harry Rostovtsev.
 * All other rights reserved.
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;qpc.h&quot;
#include &quot;ntag_ao.h&quot;
#include &quot;bsp.h&quot;
#include &quot;signals.h&quot;
#include &quot;ntag.h&quot;
#include &quot;i2c.h&quot;

/* Compile-time called macros ------------------------------------------------*/
//Q_DEFINE_THIS_FILE

/* Private typedefs ----------------------------------------------------------*/
/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables, objects, and function prototypes -----------------------*/
$declare(AOs::QpcNtag)

static QpcNtag l_qpcNtag;                      /**&lt; single instance of the AO */

QActive * const AO_QpcNtag = (QActive *)&amp;l_qpcNtag.super; /**&lt; Opaque pointer */

$declare(AOs::QpcNtag_regReadDoneCallback)

/* Public and Exported functions ---------------------------------------------*/
$define(AOs::QpcNtag_ctor)

/* Private functions ---------------------------------------------------------*/
$define(AOs::QpcNtag)
$define(AOs::QpcNtag_regReadDoneCallback)</text>
  </file>
 </directory>
</model>
